##### [[中等]]
##### [[dp]]

1. 定义状态：由于有两个字符串，且子序列是由前往后的。那么，对于某个中间状态 $[i, j]$ -> 一个字符串遍历到第 $i$ 个位置，另一个字符串遍历到 $j$ 位置。此时他们最长公共子序列长度要判断当前位置字符是否相同。如果相同，代表它们的公共子序列长度要加一。如果不相同，则判断 $i$ 与 $j - 1$ 以及 $i - 1$ 和 $j$ 公共子序列的长度的大小，并保留大的。

2. 确定状态转移方程：根据状态，我们需要两个变量来记录。故我们可以定义 $dp[i][j]$ 表示 一个字符串的第 $1$ 到 $i$ 个字符 和 另一个字符串的第 $1$ 到 $j$ 个字符 的最长公共子序列的长度，则
$$ 
dp[i][j]=\left\{
\begin{aligned}
&dp[i - 1][j - 1] + 1 &(第 \ i个和第 \ j个字符相同\ ) \\
&max(dp[i - 1][j], dp[i][j - 1]) &(第 \ i个和第 \ j个字符不同\ ) \\ 
\end{aligned}
\right.
$$

3. 确定初始状态：当字符长度为 $0$ 时，无公共子序列，故 $dp[i][0] = dp[j][0] = 0$ 。

4. 进行状态转移：由于有两个字符串，且子序列是由短到长的。故我们可以在固定一个字符串的某个字符的情况下遍历另一个字符串。遍历完后，固定的字符串添加一个字符后继续遍历另一个字符串。
5. 返回要求的结果：根据两个字符串长度返回对应的 $dp[i][j]$ 。
