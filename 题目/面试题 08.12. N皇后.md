##### [[困难]]
##### [[回溯]]

当某个位置 $[i, j]$ 有皇后时，对应的横($i$)，竖($j$)，撇($i - j$)，捺($i + j$) 都不能再有其它皇后。我们可以利用 $Set$ 来记录位置 $[i, j]$ 有皇后时，其它皇后不能放的所有位置。
遍历每一行的每一列，如果 $Set$ 中没有该位置的值（其它皇后不会影响到该位置），那么我们先假设让该行的皇后放在这里，继续遍历下一行。如之后的尝试中都指明该位置不是正确的位置，我们进行回溯（把 $Set$ 中关于该位置的信息删除），尝试该行的其它列。

代码如下：
```java
class Solution {
	int level;
	List<List<String>> ans;
	Set<Integer> row, col, pie, nai;
	public List<List<String>> solveNQueens(int n) {
		//思路:回溯
			this.row = new HashSet<>();
		this.col = new HashSet<>();
		this.pie = new HashSet<>();
		this.nai = new HashSet<>();
		this.level = n;
		this.ans = new ArrayList<>();
		//用于记录每行的第几列可以放皇后
		int[] queen = new int[n];
		Arrays.fill(queen, -1);
		DFS(0, queen);
		return this.ans;
	}
	public void DFS(int n, int[] pos){
		if (n == this.level){
			List<String> draw = draw(pos);
			this.ans.add(draw);
			return;
		}
		for (int cols = 0; cols < this.level; cols++) {
			//如果该位置不会被其他皇后攻击到
			if (!col.contains(cols) && !row.contains(n)
				&& !pie.contains(n - cols) && !nai.contains(n + cols)){
				col.add(cols);
				row.add(n);
				pie.add(n - cols);
				nai.add(n + cols);
				pos[n] = cols;
				//继续往下走
				DFS(n + 1, pos);
				//如果从递归里出来了,进行回溯
				col.remove(cols);
				row.remove(n);
				pie.remove(n - cols);
				nai.remove(n + cols);
				pos[n] = -1;
			}
		}
	}
	public List<String> draw(int[] pos){
		List<String> temp = new ArrayList<>();
		//遍历行
		for (int po : pos) {
			StringBuilder str = new StringBuilder();
			//遍历列
			for (int j = 0; j < pos.length; j++) {
				if (j == po) {
					str.append("Q");
				} else {
					str.append(".");
				}
			}
			temp.add(str.toString());
		}
		return temp;
	}
}
```
- 时间复杂度:$O(N!)$
- 空间复杂度:$O(N)$